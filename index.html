<!DOCTYPE html>
<html>
  <head>
    <title>Ajechess</title>
    <script>
      class Piece {
        constructor(isWhite, image) {
          this.isWhite = isWhite;
          this.image = "src/ajechess/iconos/" + (isWhite ? "blanco" : "negro")
            + "/" + image + ".png";
          this.jumps = [];
          this.directions = [];
        }
      }

      class Pawn extends Piece {
        constructor(isWhite) {
          super(isWhite, "peon");
          var direction = isWhite ? -1 : 1;
          this.jumps = [[1, direction], [-1, direction]];
        }
      }

      class Bishop extends Piece {
        constructor(isWhite) {
          super(isWhite, "alfil");
          this.directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        }
      }

      class Knight extends Piece {
        constructor(isWhite) {
          super(isWhite, "caballo");
          this.jumps = [[2, 1], [2, -1], [1, 2], [1, -2],
            [-2, 1], [-2, -1], [-1, 2], [-1, -2]];
        }
      }

      class Rook extends Piece {
        constructor(isWhite) {
          super(isWhite, "torre");
          this.directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
        }
      }

      class Queen extends Piece {
        constructor(isWhite) {
          super(isWhite, "dama");
          this.directions = [[1, 1], [1, -1], [-1, 1], [-1, -1],
            [1, 0], [-1, 0], [0, 1], [0, -1]];
        }
      }

      class King extends Piece {
        constructor(isWhite) {
          super(isWhite, "rey");
          this.jumps = [[1, 1], [1, 0], [1, -1], [0, 1],
            [0, -1], [-1, 1], [-1, 0], [-1, -1]];
        }
      }

      function rgb(color) {
        return "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
      }

      function emptyBoard() {
        board = [
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
          [null, null, null, null, null, null, null, null],
        ];
      }

      function resetBoard() {
        board = [
          [new Rook(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Rook(true)],
          [new Knight(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Knight(true)],
          [new Bishop(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Bishop(true)],
          [new Queen(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Queen(true)],
          [new King(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new King(true)],
          [new Bishop(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Bishop(true)],
          [new Knight(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Knight(true)],
          [new Rook(false), new Pawn(false), null, null,
            null, null, new Pawn(true), new Rook(true)]
        ];
      }

      function mouseClickOnCanvas(event) {
        var rect = c.getBoundingClientRect();
        var i = Math.floor((event.clientX - rect.left) / cellWidth);
        var j = Math.floor((event.clientY - rect.top) / cellWidth);
        var update = false;
        if (i >= 0 && i < numCells && j >= 0 && j < numCells) {
          if (selected) {
            if (selected[0] >= 0 && selected[0] < numCells
              && selected[1] >= 0 && selected[1] < numCells) {
              var selectedPiece = board[selected[0]][selected[1]];
              if (!board[i][j] || board[i][j].isWhite != selectedPiece.isWhite){
                board[i][j] = selectedPiece;
                board[selected[0]][selected[1]] = null;
              }
            } else if (selected[0] - reserveI >= 0
              && selected[0] - reserveI < reserveRows
              && selected[1] - reserveJ >= 0
              && selected[1] - reserveJ < reserveCols) {
              board[i][j] =
                reserve[selected[0] - reserveI][selected[1] - reserveJ];
            }
            selected = null;
            update = true;
          } else if (board[i][j]) {
            selected = [i, j];
            update = true;
          }
        } else {
          if (selected && selected[0] >= 0 && selected[0] < numCells
            && selected[1] >= 0 && selected[1] < numCells) {
            board[selected[0]][selected[1]] = null;
            selected = null;
            update = true;
          } else if (i - reserveI >= 0 && i - reserveI < reserveRows
            && j - reserveJ >= 0 && j - reserveJ < reserveCols) {
            selected = [i, j];
            update = true;
          } else if (i == emptyI && j == emptyJ) {
            emptyBoard();
            update = true;
          } else if (i == resetI && j == resetJ) {
            resetBoard();
            update = true;
          }
        }
        if (update) {
          updateBoard();
        }
      }

      function initBoard() {
        cellWidth = 64;
        numCells = 8;
        fontSize = 16;
        margin = 4;
        maxColor = 255;
        colorSlope = 32;
        selectedWidth = 2;
        regularWidth = 1;
        emptyText = "EMPTY";
        emptyI = 0;
        emptyJ = 9;
        resetText = "RESET";
        resetI = 0;
        resetJ = 10;
        c = document.getElementById("canvium");
        c.width = numCells * cellWidth;
        c.height = (numCells + 3) * cellWidth;
        c.addEventListener("mousedown", mouseClickOnCanvas);
        ctx = c.getContext("2d");
        ctx.font = "16px monospace";
        resetBoard();
        reserveI = 2;
        reserveJ = 9;
        reserveRows = 6;
        reserveCols = 2;
        reserve = [
          [new Pawn(false), new Pawn(true)],
          [new Knight(false), new Knight(true)],
          [new Bishop(false), new Bishop(true)],
          [new Rook(false), new Rook(true)],
          [new Queen(false), new Queen(true)],
          [new King(false), new King(true)],
        ];
        selected = null;
      }

      function calculateThreat() {
        whiteThreat = [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
        ];
        blackThreat = [
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
        ];
        for (var i = 0; i < numCells; ++i) {
          for (var j = 0; j < numCells; ++j) {
            var piece = board[i][j];
            if (piece) {
              for (jump of piece.jumps) {
                jumpX = i + jump[0];
                jumpY = j + jump[1];
                if (jumpX >= 0 && jumpX < numCells
                  && jumpY >= 0 && jumpY < numCells) {
                  if (piece.isWhite) {
                    ++whiteThreat[jumpX][jumpY];
                  } else {
                    ++blackThreat[jumpX][jumpY];
                  }
                }
              }
              for (direction of piece.directions) {
                for (var k = 1; k < numCells; ++k){
                  dirX = i + k * direction[0];
                  dirY = j + k * direction[1];
                  if (dirX < 0 || dirX >= numCells
                    || dirY < 0 || dirY >= numCells) {
                    break;
                  }
                  if (piece.isWhite) {
                    ++whiteThreat[dirX][dirY];
                  } else {
                    ++blackThreat[dirX][dirY];
                  }
                  if (board[dirX][dirY]) {
                    break;
                  }
                }
              }
            }
          }
        }
      }

      function onloadDraw(image, x, y) {
        var localImage = image;
        var localX = x;
        var localY = y;
        return function () {
          ctx.drawImage(localImage, localX, localY, cellWidth, cellWidth);
        }
      }

      function drawBoard() {
        for (var i = 0; i < numCells; ++i) {
          for (var j = 0; j < numCells; ++j) {
            var cellX = i * cellWidth;
            var cellY = j * cellWidth;
            var wt = whiteThreat[i][j];
            var bt = blackThreat[i][j];
            ctx.fillStyle = rgb([
              maxColor - colorSlope * wt,
              maxColor - colorSlope * (wt + bt),
              maxColor - colorSlope * bt]);
            ctx.fillRect(cellX, cellY, cellWidth, cellWidth);
            ctx.strokeStyle = rgb([0, 0, 0]);
            ctx.lineWidth = regularWidth;
            ctx.strokeRect(cellX, cellY, cellWidth, cellWidth);
            var textX = cellX + margin;
            ctx.fillStyle = rgb([0, 0, maxColor]);
            ctx.fillText(wt.toString(), textX, cellY + cellWidth - margin);
            ctx.fillStyle = rgb([maxColor, 0, 0]);
            ctx.fillText(bt.toString(), textX, cellY + fontSize);
            var piece = board[i][j];
            if (piece) {
              var image = new Image();
              image.onload = onloadDraw(image, cellX, cellY);
              image.src = piece.image;
            }
          }
        }
        ctx.strokeStyle = rgb([0, 0, 0]);
        ctx.lineWidth = regularWidth;
        var emptyX = emptyI * cellWidth;
        var emptyY = emptyJ * cellWidth;
        var resetX = resetI * cellWidth;
        var resetY = resetJ * cellWidth;
        ctx.strokeRect(emptyX, emptyY, cellWidth, cellWidth);
        ctx.strokeRect(resetX, resetY, cellWidth, cellWidth);
        ctx.fillStyle = rgb([0, 0, 0]);
        var textY = (cellWidth + fontSize) / 2;
        ctx.fillText(emptyText, emptyX + 2 * margin, emptyY + textY);
        ctx.fillText(resetText, resetX + 2 * margin, resetY + textY);
        for (var i = 0; i < reserveRows; ++i) {
          for (var j = 0; j < reserveCols; ++j) {
            var cellX = (i + reserveI) * cellWidth;
            var cellY = (j + reserveJ) * cellWidth;
            ctx.strokeRect(cellX, cellY, cellWidth, cellWidth);
            var image = new Image();
            image.onload = onloadDraw(image, cellX, cellY);
            image.src = reserve[i][j].image;
          }
        }
        if (selected) {
          ctx.strokeStyle = rgb([0, maxColor, 0]);
          ctx.lineWidth = selectedWidth;
          ctx.strokeRect(selected[0] * cellWidth, selected[1] * cellWidth,
            cellWidth, cellWidth);
        }
      }

      function updateBoard() {
        calculateThreat();
        drawBoard();
      }

      function onload() {
        initBoard();
        updateBoard();
      }
    </script>
  </head>
  <body onload="onload()">
    <canvas id="canvium"></canvas>
  </body>
</html>
